/* Generated by Nimrod Compiler v0.9.5 */
/*   (c) 2014 Andreas Rumpf */
/* The generated code is subject to the original license. */
/* Compiled for: Linux, amd64, gcc */
/* Command for C compiler:
   gcc -c  -w  -I/usr/lib/nimrod -o /home/andreysh/Projects/nimrod/stone_head/nimcache/helper.o /home/andreysh/Projects/nimrod/stone_head/nimcache/helper.c */
#define NIM_INTBITS 64
#include "nimbase.h"

#include <math.h>
typedef NF TY726020[17];
static N_INLINE(NI, itrunc_726006)(NF v);
static N_INLINE(void, nimFrame)(TFrame* s);
static N_INLINE(void, popFrame)(void);
static N_INLINE(NF, frac_726012)(NF value);
N_NIMCALL(NF, round_726040)(NF x, NI n);
static N_INLINE(NI, addInt)(NI a, NI b);
N_NOINLINE(void, raiseOverflow)(void);
N_NOINLINE(void, raiseIndexError)(void);
N_NIMCALL(NF, roundup_726054)(NF x, NI n);
static N_INLINE(void, HEX2BHEX3D_714271)(NF* x_714277, NF y_714280);
N_NIMCALL(NF, rounddown_726083)(NF x, NI n);
N_NIMCALL(NF, intpower_726095)(NF base, NI exponent);
static N_INLINE(NI, subInt)(NI a, NI b);
NIM_CONST TY726020 stellen_726019 = {1.0000000000000000e-08,
9.9999999999999995e-08,
9.9999999999999995e-07,
1.0000000000000001e-05,
1.0000000000000000e-04,
1.0000000000000000e-03,
1.0000000000000000e-02,
1.0000000000000001e-01,
1.0000000000000000e+00,
1.0000000000000000e+01,
1.0000000000000000e+02,
1.0000000000000000e+03,
1.0000000000000000e+04,
1.0000000000000000e+05,
1.0000000000000000e+06,
1.0000000000000000e+07,
1.0000000000000000e+08}
;
extern TFrame* frameptr_13038;

static N_INLINE(void, nimFrame)(TFrame* s) {
	(*s).prev = frameptr_13038;
	frameptr_13038 = s;
}

static N_INLINE(void, popFrame)(void) {
	frameptr_13038 = (*frameptr_13038).prev;
}

static N_INLINE(NI, itrunc_726006)(NF v) {
	NI result;
	nimfr("itrunc", "helper.nim")
	result = 0;
	nimln(21, "helper.nim");
	     return (int)(v);  
      	popFrame();
	return result;
}

static N_INLINE(NF, frac_726012)(NF value) {
	NF result;
	NF LOC1;
	nimfr("frac", "helper.nim")
	result = 0;
	nimln(26, "helper.nim");
	nimln(26, "helper.nim");
	nimln(26, "helper.nim");
	nimln(26, "helper.nim");
	LOC1 = 0;
	LOC1 = trunc(value);
	result = ((NF)(value) - (NF)(LOC1));
	goto BeforeRet;
	BeforeRet: ;
	popFrame();
	return result;
}

static N_INLINE(NI, addInt)(NI a, NI b) {
	NI result;
	result = 0;
	result = (NI)((NU64)(a) + (NU64)(b));
	{
		NIM_BOOL LOC3;
		LOC3 = 0;
		LOC3 = (0 <= (NI)(result ^ a));
		if (LOC3) goto LA4;
		LOC3 = (0 <= (NI)(result ^ b));
		LA4: ;
		if (!LOC3) goto LA5;
		goto BeforeRet;
	}
	LA5: ;
	raiseOverflow();
	BeforeRet: ;
	return result;
}

N_NIMCALL(NF, round_726040)(NF x, NI n) {
	NF result;
	nimfr("round", "helper.nim")
	result = 0;
	nimln(37, "helper.nim");
	{
		NIM_BOOL LOC3;
		nimln(37, "helper.nim");
		LOC3 = 0;
		nimln(37, "helper.nim");
		LOC3 = (8 < n);
		if (LOC3) goto LA4;
		nimln(37, "helper.nim");
		LOC3 = (n < -8);
		LA4: ;
		if (!LOC3) goto LA5;
		nimln(38, "helper.nim");
		nimln(38, "helper.nim");
		result = x;
		goto BeforeRet;
	}
	goto LA1;
	LA5: ;
	{
		NF sf;
		NI TMP255;
		NF xx;
		NF LOC8;
		NF LOC9;
		NF LOC10;
		nimln(40, "helper.nim");
		nimln(40, "helper.nim");
		TMP255 = addInt(n, 8);
		if ((NU)((NI64)(TMP255)) > (NU)(16)) raiseIndexError();
		sf = stellen_726019[((NI64)(TMP255))- 0];
		nimln(41, "helper.nim");
		nimln(41, "helper.nim");
		xx = ((NF)(x) * (NF)(sf));
		nimln(42, "helper.nim");
		nimln(42, "helper.nim");
		nimln(42, "helper.nim");
		nimln(42, "helper.nim");
		nimln(42, "helper.nim");
		LOC8 = 0;
		LOC8 = trunc(xx);
		nimln(42, "helper.nim");
		nimln(42, "helper.nim");
		nimln(42, "helper.nim");
		LOC9 = 0;
		LOC9 = frac_726012(xx);
		LOC10 = 0;
		LOC10 = trunc(((NF)(LOC9) * (NF)(2.0000000000000000e+00)));
		result = ((NF)(((NF)(LOC8) + (NF)(LOC10))) / (NF)(sf));
		goto BeforeRet;
	}
	LA1: ;
	BeforeRet: ;
	popFrame();
	return result;
}

static N_INLINE(void, HEX2BHEX3D_714271)(NF* x_714277, NF y_714280) {
	nimfr("+=", "system.nim")
	nimln(2706, "system.nim");
	nimln(2706, "system.nim");
	(*x_714277) = ((NF)((*x_714277)) + (NF)(y_714280));
	popFrame();
}

N_NIMCALL(NF, roundup_726054)(NF x, NI n) {
	NF result;
	nimfr("roundUp", "helper.nim")
	result = 0;
	nimln(46, "helper.nim");
	{
		NIM_BOOL LOC3;
		nimln(46, "helper.nim");
		LOC3 = 0;
		nimln(46, "helper.nim");
		LOC3 = (8 < n);
		if (LOC3) goto LA4;
		nimln(46, "helper.nim");
		LOC3 = (n < -8);
		LA4: ;
		if (!LOC3) goto LA5;
		nimln(47, "helper.nim");
		nimln(47, "helper.nim");
		result = x;
		goto BeforeRet;
	}
	goto LA1;
	LA5: ;
	{
		NF sf;
		NI TMP256;
		NF xx;
		NF LOC13;
		nimln(49, "helper.nim");
		nimln(49, "helper.nim");
		TMP256 = addInt(n, 8);
		if ((NU)((NI64)(TMP256)) > (NU)(16)) raiseIndexError();
		sf = stellen_726019[((NI64)(TMP256))- 0];
		nimln(50, "helper.nim");
		nimln(50, "helper.nim");
		xx = ((NF)(x) * (NF)(sf));
		nimln(51, "helper.nim");
		{
			NF LOC10;
			nimln(51, "helper.nim");
			nimln(51, "helper.nim");
			LOC10 = 0;
			LOC10 = frac_726012(xx);
			if (!(0.0 < LOC10)) goto LA11;
			nimln(51, "helper.nim");
			HEX2BHEX3D_714271(&xx, 1.0000000000000000e+00);
		}
		LA11: ;
		nimln(52, "helper.nim");
		nimln(52, "helper.nim");
		nimln(52, "helper.nim");
		nimln(52, "helper.nim");
		LOC13 = 0;
		LOC13 = trunc(xx);
		result = ((NF)(LOC13) / (NF)(sf));
		goto BeforeRet;
	}
	LA1: ;
	BeforeRet: ;
	popFrame();
	return result;
}

N_NIMCALL(NF, rounddown_726083)(NF x, NI n) {
	NF result;
	nimfr("roundDown", "helper.nim")
	result = 0;
	nimln(55, "helper.nim");
	{
		NIM_BOOL LOC3;
		nimln(55, "helper.nim");
		LOC3 = 0;
		nimln(55, "helper.nim");
		LOC3 = (8 < n);
		if (LOC3) goto LA4;
		nimln(55, "helper.nim");
		LOC3 = (n < -8);
		LA4: ;
		if (!LOC3) goto LA5;
		nimln(56, "helper.nim");
		nimln(56, "helper.nim");
		result = x;
		goto BeforeRet;
	}
	goto LA1;
	LA5: ;
	{
		NF sf;
		NI TMP257;
		NF xx;
		NF LOC8;
		nimln(58, "helper.nim");
		nimln(58, "helper.nim");
		TMP257 = addInt(n, 8);
		if ((NU)((NI64)(TMP257)) > (NU)(16)) raiseIndexError();
		sf = stellen_726019[((NI64)(TMP257))- 0];
		nimln(59, "helper.nim");
		nimln(59, "helper.nim");
		xx = ((NF)(x) * (NF)(sf));
		nimln(60, "helper.nim");
		nimln(60, "helper.nim");
		nimln(60, "helper.nim");
		nimln(60, "helper.nim");
		LOC8 = 0;
		LOC8 = trunc(xx);
		result = ((NF)(LOC8) / (NF)(sf));
		goto BeforeRet;
	}
	LA1: ;
	BeforeRet: ;
	popFrame();
	return result;
}

static N_INLINE(NI, subInt)(NI a, NI b) {
	NI result;
	result = 0;
	result = (NI)((NU64)(a) - (NU64)(b));
	{
		NIM_BOOL LOC3;
		LOC3 = 0;
		LOC3 = (0 <= (NI)(result ^ a));
		if (LOC3) goto LA4;
		LOC3 = (0 <= (NI)(result ^ (NI)((NU64) ~(b))));
		LA4: ;
		if (!LOC3) goto LA5;
		goto BeforeRet;
	}
	LA5: ;
	raiseOverflow();
	BeforeRet: ;
	return result;
}

N_NIMCALL(NF, intpower_726095)(NF base, NI exponent) {
	NF result;
	NI y;
	NF lbase;
	nimfr("IntPower", "helper.nim")
	result = 0;
	nimln(64, "helper.nim");
	nimln(64, "helper.nim");
	if (exponent == (IL64(-9223372036854775807) - IL64(1))) raiseOverflow();
	y = (NI64)abs(exponent);
	nimln(65, "helper.nim");
	lbase = base;
	nimln(66, "helper.nim");
	result = 1.0000000000000000e+00;
	nimln(67, "helper.nim");
	while (1) {
		nimln(67, "helper.nim");
		if (!(0 < y)) goto LA1;
		nimln(68, "helper.nim");
		while (1) {
			nimln(68, "helper.nim");
			nimln(68, "helper.nim");
			if (!(((NI) ((NI)(y & 1))) == 0)) goto LA2;
			nimln(69, "helper.nim");
			nimln(69, "helper.nim");
			y = (NI)((NU64)(y) >> (NU64)(1));
			nimln(70, "helper.nim");
			nimln(70, "helper.nim");
			lbase = ((NF)(lbase) * (NF)(lbase));
		} LA2: ;
		nimln(71, "helper.nim");
		y = subInt(y, 1);
		nimln(72, "helper.nim");
		nimln(72, "helper.nim");
		result = ((NF)(result) * (NF)(lbase));
	} LA1: ;
	nimln(73, "helper.nim");
	{
		nimln(73, "helper.nim");
		if (!(exponent < 0)) goto LA5;
		nimln(74, "helper.nim");
		nimln(74, "helper.nim");
		result = ((NF)(1.0000000000000000e+00) / (NF)(result));
	}
	LA5: ;
	popFrame();
	return result;
}
N_NOINLINE(void, helperInit)(void) {
	nimfr("helper", "helper.nim")
	popFrame();
}

N_NOINLINE(void, helperDatInit)(void) {
}

